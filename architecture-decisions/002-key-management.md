## ADR 2: Key Management and Revealing MAC Keys

### Context

Previous versions of the OTR protocol use a mechanism called the Diffie-Hellman
ratchet (DH Ratchet) to ratchet key material when messages were exchanged. This
ratcheting approach consists of attaching new DH contributions to sent
messages: with each sent message, the sender advertises a new DH value. Message
keys are then computed from the latest acknowledged DH values.

This three step DH Ratchet works as follows:

1. Alice wants to send an encrypted message to Bob:
   * She picks the most recent of her own D-H encryption keys (`pubA`) that Bob
     has acknowledged receiving (by using it in a Data Message or in the AKE).
   * If the above key is Alice's most recent key, she generates a new D-H key
     (`next_dh`).
   * She picks the most recent of Bob's D-H encryption keys (`pubB`) that she
     has received from him (either in a Data Message or in the AKE).
   * She uses Diffie-Hellman to compute a shared secret from the two keys
     (`pubA` and `pubB`), and a message key. She encrypts a message with the
     latest.
   * She sends the encrypted message to Bob and "advertises" her next
     Diffie-Hellman key `next_dh`.
2. Bob receives the encrypted message from Alice:
   * He uses Diffie-Hellman to compute a shared secret from the two keys
     (`pubA` and `pubB`), and a message key. He decrypts the message with the
     latest.
   * If he wants to send an encrypted message:
     * He "acknowledges" Alice's next Diffie-Hellman key `next_dh` as `pubA`.
     * He generates a new D-H key (`next_dh`).
     * He picks the most recent of Alice's D-H encryption keys (`pubA`) that
       he has received from her.
     * He uses Diffie-Hellman to compute a shared secret from the two keys
       (`pubA` and `pubB`), and a message key. He encrypts a message with the
       latest.
     * He sends the encrypted message to Alice and "advertises" his next
       Diffie-Hellman key `next_dh`.
 3. Alice receives the encrypted message from Bob and proceeds to decrypt it
    as previously stated.

This design introduces backward secrecy within conversations since a
compromised key will be regularly replaced with new key material. A
disadvantage of this DH Ratchet is that session keys might not be renewed for
every message (forward secrecy is, therefore, only partially provided). It also
lacks out-of-order resilience: if a message arrives after a newly advertised
key is accepted, then the necessary decryption key will be already deleted and
the message will not be able to be decrypted.

In order to improve the forward secrecy of the DH Ratchet, both ratchet
approaches can be combined: session keys produced by DH ratchets are used to
seed per-participant KDF symmetric ratchets. Messages are then encrypted using
keys produced by this KDF symmetric ratchets, frequently refreshed by the DH
Ratchet, executed when a participant wants to send a message after one has
already been received. This resulting double ratchet (called the "Double Ratchet
Algorithm" [\[1\]](#references)) provides forward secrecy across messages due
to the KDF symmetric ratchets, but also backward secrecy since compromised KDF
keys will eventually be replaced by new seeds. To achieve out-of-order
resilience, the double ratchet makes use of a second derivation function within
its KDF symmetric ratchets. While the KDF symmetric ratchets are advanced
normally, the KDF keys are passed through a second derivation function before
being used for encryption.

The double ratchet, nevertheless, does not provide asynchronicity by itself,
but it can be combined with a prekey scheme for it. Prekeys are one-time
ephemeral public DH contributions that have been uploaded in advance to an
untrusted server.

We consider using the Double Ratchet Algorithm to improve forward secrecy,
while maintaining the same security properties of prior OTR versions, such as
message deniability. This is achieved because messages are authenticated with
shared MAC keys rather than with signatures generated by long-term keys. OTR,
also, publishes the MAC keys and uses malleable encryption, to expand the set
of possible message forgers. OTRv4, therefore, will improve forward secrecy,
support out-of-order resilence and asynchronicity (in the form of prekey
messages uploaded to a server).

OTR version 2 contains a vulnerability related to message integrity when the
revelation of MAC keys is done immediately by both participants in a
conversation [\[2\]](#references). Two potential solutions are possible:

1. Only the receiver can reveal MAC keys, which gives weaker deniability as
   it puts full trust in receiver.
2. Both the sender and receiver can reveal MAC keys, but the sender must reveal
   only after two ratchet generations.

OTRv3 made the decision to only allow the receiver to reveal MAC keys.

Therefore, to reveal MAC keys in the Double Ratchet:

1. The receiver of data messages can reveal MAC keys on the first message sent
   per ratchet.
2. The participant expiring the session can reveal MAC keys on the sent TLV
   type 1.

### Decision

For OTRv4, we decided to use the Double Ratchet Algorithm for key management.
This allows OTRv4 to support out-of-order resilence and to improve forward
secrecy (in the form of per-message forward secrecy).

As OTRv4 supports an out-of-order network model, message keys should be stored
for a reasonable amount of time so skipped messages can be decrypted.
Implementers should, nevertheless, be careful around the storage of message keys
as attackers can try to cause denial-of-service (by storing large amounts of
message keys), or to try to capture and retroactively decrypt messages.

Sent data messages can always have a type `7 TLV` attached. In the case of the
receiver, this participant is never sure of when a message corresponding to a
stored skipped message key will arrive with this TLV attached. For this reason,
every time a message key is stored, an extra symmetric key is also derived an
stored. Upon receipt of the message corresponding to the stored message key, the
extra symmetric key can either be used or discarded.

We decided that only the receiver will reveal MAC keys on the first message
sent of every ratchet (even the MAC keys from stored messages keys). When the
session is expired or when stored message keys are deleted, their corresponding
MAC keys are placed in the `old_mac_keys` list so they can be later revealed
in either the next sent data message or in the immediate TLV type 1 sent when
a session is expired.

### Consequences

This heavily changes how data is exchanged as compared with previous versions.

We achieve improved forward secrecy, but key management and ratcheting processes
become somewhat complex because of the many types of keys involved.

As a consequence of allowing an out-of-order network model, message keys should
be stored. This also changes how fragmentation of data messages work.

### References


1. Marlinspike, M. (2013). *Advanced cryptographic ratcheting*, Signal blog.
   Available at: https://signal.org/blog/advanced-ratcheting/
2. Bonneau, J., Morrison, A. (2006) *Finite-State Security Analysis of OTR
   Version 2*. Available at:
   http://www.jbonneau.com/doc/BM06-OTR_v2_analysis.pdf
3. Unger, N., Dechand, S., Bonneau, J., Fahl, S., Perl, H., Goldberg, I., Smith,
   M. (2015). *SoK: Secure Messaging*, CACR, Available at:
   http://cacr.uwaterloo.ca/techreports/2015/cacr2015-02.pdf